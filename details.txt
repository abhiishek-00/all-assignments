please create a python as well as golang script for the below requirements
requirements-
1. take input as csv having repository metadata
2. clone the repository
3. check in the root directory if pom.xml or build.gradle is present or not
4. read either pom.xml or build.gradle & find out the java version mentioned in the file
5. create a new copy of the original csv & add two columns-
	a. build_tool- maven if pom is present, gradle if build.gradle is present
	b. java_version- take value from step 4
6. delete the clone directory
7. run steps 1 to 6 concurrently & safely


<java.version>8</java.version>

languageVersion = JavaLanguageVersion.of(17) or if not present then use sourceCompatibility


import os
import csv
import shutil
from git import Repo
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor

def clone_repo(repo_url, clone_dir):
    try:
        Repo.clone_from(repo_url, clone_dir)
        return True
    except Exception as e:
        print(f"Error cloning repo {repo_url}: {e}")
        return False

def check_build_file(clone_dir):
    pom_path = os.path.join(clone_dir, 'pom.xml')
    gradle_path = os.path.join(clone_dir, 'build.gradle')
    
    if os.path.exists(pom_path):
        return 'maven', pom_path
    elif os.path.exists(gradle_path):
        return 'gradle', gradle_path
    return None, None

def extract_java_version(build_file, build_tool):
    java_version = "Unknown"
    try:
        if build_tool == 'maven':
            tree = ET.parse(build_file)
            root = tree.getroot()
            namespaces = {'xmlns': 'http://maven.apache.org/POM/4.0.0'}
            java_version_tag = root.find(".//xmlns:properties/xmlns:java.version", namespaces)
            if java_version_tag is not None:
                java_version = java_version_tag.text
        elif build_tool == 'gradle':
            with open(build_file, 'r') as f:
                content = f.read()
                if "JavaLanguageVersion.of(" in content:
                    start = content.find("JavaLanguageVersion.of(") + len("JavaLanguageVersion.of(")
                    end = content.find(")", start)
                    java_version = content[start:end].strip()
                elif "sourceCompatibility" in content:
                    for line in content.splitlines():
                        if 'sourceCompatibility' in line:
                            java_version = line.split('=')[-1].strip().replace("'", "").replace('"', '')
                            break
    except Exception as e:
        print(f"Error extracting Java version from {build_file}: {e}")
    
    return java_version

def process_repo(row, output_rows):
    repo_name = row['repo_name']
    repo_url = row['repo_url']
    clone_dir = f'./clones/{repo_name}'

    if clone_repo(repo_url, clone_dir):
        build_tool, build_file = check_build_file(clone_dir)
        if build_tool:
            java_version = extract_java_version(build_file, build_tool)
            row['build_tool'] = build_tool
            row['java_version'] = java_version
        else:
            row['build_tool'] = 'N/A'
            row['java_version'] = 'N/A'

        shutil.rmtree(clone_dir)  # Remove the cloned directory
    else:
        row['build_tool'] = 'N/A'
        row['java_version'] = 'N/A'

    output_rows.append(row)

def main():
    input_csv = 'repos.csv'
    output_csv = 'repos_output.csv'
    output_rows = []

    with open(input_csv, mode='r') as file:
        reader = csv.DictReader(file)
        rows = list(reader)

    with ThreadPoolExecutor() as executor:
        executor.map(lambda row: process_repo(row, output_rows), rows)

    fieldnames = ['repo_name', 'repo_url', 'build_tool', 'java_version']
    with open(output_csv, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(output_rows)

if __name__ == "__main__":
    main()




package main

import (
	"encoding/csv"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
)

type RepoMetadata struct {
	Name        string
	URL         string
	BuildTool   string
	JavaVersion string
}

var wg sync.WaitGroup
var mutex sync.Mutex

func cloneRepo(repoName, repoURL string) error {
	cloneDir := fmt.Sprintf("./clones/%s", repoName)
	cmd := exec.Command("git", "clone", repoURL, cloneDir)
	if err := cmd.Run(); err != nil {
		return err
	}
	return nil
}

func checkBuildFile(repoName string) (string, string) {
	cloneDir := fmt.Sprintf("./clones/%s", repoName)
	pomFile := filepath.Join(cloneDir, "pom.xml")
	gradleFile := filepath.Join(cloneDir, "build.gradle")

	if _, err := os.Stat(pomFile); err == nil {
		return "maven", pomFile
	} else if _, err := os.Stat(gradleFile); err == nil {
		return "gradle", gradleFile
	}
	return "", ""
}

func extractJavaVersion(buildTool, buildFile string) string {
	if buildTool == "maven" {
		cmd := exec.Command("grep", "-m", "1", "<java.version>", buildFile)
		out, _ := cmd.Output()
		javaVersion := strings.TrimSpace(strings.ReplaceAll(string(out), "<java.version>", ""))
		javaVersion = strings.ReplaceAll(javaVersion, "</java.version>", "")
		return javaVersion
	} else if buildTool == "gradle" {
		// Check for JavaLanguageVersion first
		cmd := exec.Command("grep", "-m", "1", "JavaLanguageVersion.of", buildFile)
		out, _ := cmd.Output()
		if len(out) > 0 {
			start := strings.Index(string(out), "JavaLanguageVersion.of(") + len("JavaLanguageVersion.of(")
			end := strings.Index(string(out), ")")
			return strings.TrimSpace(string(out)[start:end])
		}

		// Fallback to sourceCompatibility
		cmd = exec.Command("grep", "-m", "1", "sourceCompatibility", buildFile)
		out, _ = cmd.Output()
		parts := strings.Split(string(out), "=")
		if len(parts) > 1 {
			return strings.TrimSpace(parts[1])
		}
	}
	return "Unknown"
}

func processRepo(repo RepoMetadata, results *[]RepoMetadata) {
	defer wg.Done()

	if err := cloneRepo(repo.Name, repo.URL); err != nil {
		repo.BuildTool = "N/A"
		repo.JavaVersion = "N/A"
	} else {
		buildTool, buildFile := checkBuildFile(repo.Name)
		if buildTool != "" {
			repo.BuildTool = buildTool
			repo.JavaVersion = extractJavaVersion(buildTool, buildFile)
		} else {
			repo.BuildTool = "N/A"
			repo.JavaVersion = "N/A"
		}
		os.RemoveAll(fmt.Sprintf("./clones/%s", repo.Name))
	}

	mutex.Lock()
	*results = append(*results, repo)
	mutex.Unlock()
}

func main() {
	inputFile, err := os.Open("repos.csv")
	if err != nil {
		fmt.Println("Error opening input file:", err)
		return
	}
	defer inputFile.Close()

	reader := csv.NewReader(inputFile)
	records, err := reader.ReadAll()
	if err != nil {
		fmt.Println("Error reading CSV:", err)
		return
	}

	var repos []RepoMetadata
	for _, record := range records[1:] {
		repos = append(repos, RepoMetadata{
			Name: record[0],
			URL:  record[1],
		})
	}

	var results []RepoMetadata
	for _, repo := range repos {
		wg.Add(1)
		go processRepo(repo, &results)
	}

	wg.Wait()

	outputFile, err := os.Create("repos_output.csv")
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer outputFile.Close()

	writer := csv.NewWriter(outputFile)
	defer writer.Flush()

	writer.Write([]string{"repo_name", "repo_url", "build_tool", "java_version"})
	for _, result := range results {
		writer.Write([]string{result.Name, result.URL, result.BuildTool, result.JavaVersion})
	}
}




package main

import (
	"encoding/csv"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
)

type RepoMetadata struct {
	Name        string
	URL         string
	BuildTool   string
	JavaVersion string
}

var semaphore = make(chan struct{}, 25) // Limit to 25 concurrent goroutines
var wg sync.WaitGroup
var mutex sync.Mutex

func cloneRepo(repoName, repoURL string) error {
	cloneDir := fmt.Sprintf("./clones/%s", repoName)
	cmd := exec.Command("git", "clone", repoURL, cloneDir)
	if err := cmd.Run(); err != nil {
		return err
	}
	return nil
}

func checkBuildFile(repoName string) (string, string) {
	cloneDir := fmt.Sprintf("./clones/%s", repoName)
	pomFile := filepath.Join(cloneDir, "pom.xml")
	gradleFile := filepath.Join(cloneDir, "build.gradle")

	if _, err := os.Stat(pomFile); err == nil {
		return "maven", pomFile
	} else if _, err := os.Stat(gradleFile); err == nil {
		return "gradle", gradleFile
	}
	return "", ""
}

func extractJavaVersion(buildTool, buildFile string) string {
	if buildTool == "maven" {
		cmd := exec.Command("grep", "-m", "1", "<java.version>", buildFile)
		out, _ := cmd.Output()
		javaVersion := strings.TrimSpace(strings.ReplaceAll(string(out), "<java.version>", ""))
		javaVersion = strings.ReplaceAll(javaVersion, "</java.version>", "")
		return javaVersion
	} else if buildTool == "gradle" {
		cmd := exec.Command("grep", "-m", "1", "JavaLanguageVersion.of", buildFile)
		out, _ := cmd.Output()
		if len(out) > 0 {
			start := strings.Index(string(out), "JavaLanguageVersion.of(") + len("JavaLanguageVersion.of(")
			end := strings.Index(string(out), ")")
			return strings.TrimSpace(string(out)[start:end])
		}

		cmd = exec.Command("grep", "-m", "1", "sourceCompatibility", buildFile)
		out, _ = cmd.Output()
		parts := strings.Split(string(out), "=")
		if len(parts) > 1 {
			return strings.TrimSpace(parts[1])
		}
	}
	return "Unknown"
}

func processRepo(repo RepoMetadata, results *[]RepoMetadata) {
	defer wg.Done()

	// Wait for a slot
	semaphore <- struct{}{}

	if err := cloneRepo(repo.Name, repo.URL); err != nil {
		repo.BuildTool = "N/A"
		repo.JavaVersion = "N/A"
	} else {
		buildTool, buildFile := checkBuildFile(repo.Name)
		if buildTool != "" {
			repo.BuildTool = buildTool
			repo.JavaVersion = extractJavaVersion(buildTool, buildFile)
		} else {
			repo.BuildTool = "N/A"
			repo.JavaVersion = "N/A"
		}
		os.RemoveAll(fmt.Sprintf("./clones/%s", repo.Name))
	}

	// Release the slot
	<-semaphore

	mutex.Lock()
	*results = append(*results, repo)
	mutex.Unlock()
}

func main() {
	inputFile, err := os.Open("repos.csv")
	if err != nil {
		fmt.Println("Error opening input file:", err)
		return
	}
	defer inputFile.Close()

	reader := csv.NewReader(inputFile)
	records, err := reader.ReadAll()
	if err != nil {
		fmt.Println("Error reading CSV:", err)
		return
	}

	var repos []RepoMetadata
	for _, record := range records[1:] {
		repos = append(repos, RepoMetadata{
			Name: record[0],
			URL:  record[1],
		})
	}

	var results []RepoMetadata
	for _, repo := range repos {
		wg.Add(1)
		go processRepo(repo, &results)
	}

	wg.Wait()

	outputFile, err := os.Create("repos_output.csv")
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer outputFile.Close()

	writer := csv.NewWriter(outputFile)
	defer writer.Flush()

	writer.Write([]string{"repo_name", "repo_url", "build_tool", "java_version"})
	for _, result := range results {
		writer.Write([]string{result.Name, result.URL, result.BuildTool, result.JavaVersion})
	}
}




import os
import csv
import shutil
from git import Repo
import xml.etree.ElementTree as ET
from concurrent.futures import ThreadPoolExecutor, as_completed

def clone_repo(repo_url, clone_dir):
    try:
        Repo.clone_from(repo_url, clone_dir)
        return True
    except Exception as e:
        print(f"Error cloning repo {repo_url}: {e}")
        return False

def check_build_file(clone_dir):
    pom_path = os.path.join(clone_dir, 'pom.xml')
    gradle_path = os.path.join(clone_dir, 'build.gradle')
    
    if os.path.exists(pom_path):
        return 'maven', pom_path
    elif os.path.exists(gradle_path):
        return 'gradle', gradle_path
    return None, None

def extract_java_version(build_file, build_tool):
    java_version = "Unknown"
    try:
        if build_tool == 'maven':
            tree = ET.parse(build_file)
            root = tree.getroot()
            namespaces = {'xmlns': 'http://maven.apache.org/POM/4.0.0'}
            java_version_tag = root.find(".//xmlns:properties/xmlns:java.version", namespaces)
            if java_version_tag is not None:
                java_version = java_version_tag.text
        elif build_tool == 'gradle':
            with open(build_file, 'r') as f:
                content = f.read()
                if "JavaLanguageVersion.of(" in content:
                    start = content.find("JavaLanguageVersion.of(") + len("JavaLanguageVersion.of(")
                    end = content.find(")", start)
                    java_version = content[start:end].strip()
                elif "sourceCompatibility" in content:
                    for line in content.splitlines():
                        if 'sourceCompatibility' in line:
                            java_version = line.split('=')[-1].strip().replace("'", "").replace('"', '')
                            break
    except Exception as e:
        print(f"Error extracting Java version from {build_file}: {e}")
    
    return java_version

def process_repo(row):
    repo_name = row['repo_name']
    repo_url = row['repo_url']
    clone_dir = f'./clones/{repo_name}'
    result_row = row.copy()

    if clone_repo(repo_url, clone_dir):
        build_tool, build_file = check_build_file(clone_dir)
        if build_tool:
            java_version = extract_java_version(build_file, build_tool)
            result_row['build_tool'] = build_tool
            result_row['java_version'] = java_version
        else:
            result_row['build_tool'] = 'N/A'
            result_row['java_version'] = 'N/A'

        shutil.rmtree(clone_dir)  # Remove the cloned directory
    else:
        result_row['build_tool'] = 'N/A'
        result_row['java_version'] = 'N/A'

    return result_row

def main():
    input_csv = 'repos.csv'
    output_csv = 'repos_output.csv'
    output_rows = []

    with open(input_csv, mode='r') as file:
        reader = csv.DictReader(file)
        rows = list(reader)

    # Limiting to 25 threads
    with ThreadPoolExecutor(max_workers=25) as executor:
        futures = [executor.submit(process_repo, row) for row in rows]
        for future in as_completed(futures):
            output_rows.append(future.result())

    fieldnames = ['repo_name', 'repo_url', 'build_tool', 'java_version']
    with open(output_csv, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(output_rows)

if __name__ == "__main__":
    main()

